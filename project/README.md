# Allen's Manual Joystick Visualizer
#### Video Demo:  <URL HERE>
#### Description:

This project started as a quick experiment the love2d framework, intended as a trial to see if this was the direction i'd like to take for my final project. Following the guidance of the Love2d CS50 seminar, I expected to spend a couple of hours, to maybe a day or two at max, tinkering, and then starting a different more focused project if I liked it, or move on to a python app if I didn't. 

My idea was to make a manually controlled line that bounced off of the walls of the app window and made some kind of cool geometric pattern. The Love framework seemed easy and intuitive enough, but i quickly ran into several roadblocks with lua, as it resembles python, but is a lot more simplistic and less streamlined in my opinion. After sifting thru documentation i got a foothold and immediately found some inspiration with love's easy joystick support. i had an xbox controller sitting on my desk and grabbed it to try out the joystick functionality, and quickly was moving around a dot with edge detection so it didn't get lost off screen. 

Next were the lines bouncing off the sides of the screen. while I puzzled over how to do this for a while with simple algebra, the reality of computer graphics began to dawn on me, everything that is drawn on a screen must be defined in discrete mathematical graphing terms, so it was going to take a LOT of math! my first instinct was to work with angles, and vector plotting, but it seemed that would be intimidatingly complex if not possibly beyond the scope of Love as a framework. after browsing recommended love tutorials, i was drawn to the simple line and shape drawing functions as a starting point, which would only take x and y coordinates. 

after toying around in this ray optics simulator (https://phydemo.app/ray-optics/), I eventually realized with a friends help that this was a trigonometric problem that could be viewed as mirrored isoceles triangles. i used this ray optics webapp as a blackboard to draw out the different reflection cases and arrived at the old reliable "soh cah toa" trig mnemonic that i had long forgotten from sophomore year in high school. this was the first breakthru in the project and first major point of inspiration, my interest was piqued and i was exhilarated at the complex mathematical solution to the seemingly simple problem i started with. i dove in over the next day or so and quickly found myself spending more time that i initially imagined, but it felt good so i went with it.

my first major roadblock was love's inversion of the typical y axis, so i had to translate the trig concepts accordingly. visually drawing these things out in the simulator app above was extremely helpful in conceptualization and brainstorming. i got the first reflection working, and had the line being accurately and intuitively moved by the controller. 

next was to rotate the trig solution for each of the four sides of the window that the line could reflect off of. i accomplished this pretty quickly was quite satisfied with the result, but i was only bouncing a single time off the window. 

next was to create a recursive function to continue the reflections. i figured i would just feed the terminus coordinates of the new reflected line back into the trig function and create a new line. this did not work at all as expected, and i realized this was because the terminus of my reflected lines was often far off the screen, even approaching infinity, it just appeared to terminate at the window's edge. it did work in some specific angles and cases though, and i realized that i was defining the terminus of the new reflected line in terms of the opposite edge of the window from the reflection point (which can also be called the origin point of this new line). so i would need 3 different trig "rotations" for each side of the window, 12 in total: one that terminates on the opposite edge (which i already had), and 2 more for each of the adjacent edges, when the coordinates of the terminus from the first equation exceed the bounds of the window (or screen. i had integrated fullscreen capability at this point). 

several hours back at the trig drawing board and notebook pages later, i had all the math working! some hiccups and frustrations with lua along the way (archaic table functionality, indexing at 1 ?!), i had my reflection algo working, with a hard coded number of repeats as a base case. i wanted to pass the xy coords to the love line draw function as a table, but ran into more lua problems, realizing all variables are global by default (?!), and tables are passed by reference implicitly (mirroring a similar realization with C), but finally got it working!

now i had the prototype running, and had fully realized the idea that was in my head at the outset. it had taken a lot more time and effort than i imagined, but i was exhilarated and had plenty of time, so the project kept momentum. i typically listen to drum'n'bass/jungle music while i code, and found myself moving the simple reflecting line around in sync to the music. feature after feature came as inspiration during this testing, and a really satisfying workflow emerged where the line between toying/playing and testing was blurred, and what began to appear organically was a neat and idiosyncratic manifestation of my general coding environment/vibe: atmospheric and abstract forms flowing to music. 

i added a lot of new controller mappings, controlling the number of repeats and line thickness with the dpad, changing colors with the face buttons, fullscreen button, color modulation with the analog triggers, etc. the features were essentially writing themselves and i was just having fun.

another roadblock though, as the number of repeats and geometric complexity increased, my lines were starting to pull apart and have spaces in them, appearing as dotted lines. after a lot of meticulous testing, i determined that none of my math seemed to be causing this, it seems to be something about the love framework. i suspect that i may be exceeding the limited amount of memory made available to each draw operation, and so the line was being stretched to accomodate. this was solved by drawing each line with a separate draw operation, but necessitated me nerfing my reflect algorithm to a worse design that took and returned single integer coordinates rather than adding to a single table of coordinates. it looked better on screen though so i moved on. EDIT: this issue seems to come and go as i continue to build the program, and is currently only manifesting in a milder version, with the lines looking slightly rough and pixelated. this holds with the memory hypothesis but i really have no idea. i would love to understand what is going on, but havent found anything about it after extensive searches online, thru documentation and forums, and it looks fine so i'm going with it.

as the geometric complexity increased, so did the response to minute cursor movements, so i set about scaling down the speed of the cursor with inverse relation to the complexity. this worked great visually but locked the user into small immobile positions so i added a right trigger analog scaling speed boost which also scales. this involved a LOT of algebraic experimentation and revealed a lot about the translation of mathematical operations with user movement, graphing in general, and drawing. it was a very cool way to further conceptualize things like exponential relationships, asymptotes, linear, logarithmic growth, etc, and i sense an opportunity for a algebra/calculus class teaching tool in there somewhere.

a similar process unfolded for the color modulations with the added factor of random number generators, and the frame by frame constantly updating nature of visual gaming programming. i learned a lot about how the order of executed code matters in a new way in this situation.

another issue was making the edges "sticky" so the cursor would latch on and continue the reflection, allowing the user to focus on modulating the visuals and not keeping the cursor against the edge with extremely fine movement controls. this gave rise to another problem of escaping the edge stickiness when desired, which is a matter of relationship to the speed boost available to the right trigger. this is a complex task that required me to reevaluate all the previous alegbraic spitballing and balance them with one another while maintaining intuitive user controls. at the time of writing i'm still working out some kinks here, most prominently, getting stuck in corners.

the next major evolution was creating new visual modes beyond simple lines. this is where the project really took off, and it became clear that this quick experiment had actually become my final project itself. i wanted to incorporate arcs, curved lines, perhaps circles, but none of that was feasible given my time constraint at this point, as i would have to go back to the drawing board on all my trig. i'm lucky to have several friends who are software professionals, and after seeing my progress on this, they suggested i may be flirting with the limitations of the Love2d framework and Lua, and would be better served by a more robust framework like Unity. i hope to continue this as a passion project in the future on a more robust platform and possibly in 3d. 

with this understanding i searched for ways that love could accomodate further complexity with my given constraints and was able to make a polygon mode pretty quickly, but this necessitated a return to the table version of my reflection function. the compromise in visual quality was much less noticeable now that my visuals were so much more complext, and it was just better design IMO. the initial polygon mode was basic and visually unimpressive but served as inspiration and a platform for more visual complexity, because it allowed me to fill more of the screen with color. next, i was able to use the stencil fuctionality in a creative and abstract way that may not be what the developers of love intended (?) but gave me some really fun visual effects. 

from there i refined color modulations, added new and less chaotic random color modes, and had something that was now catching my roommates eyes as the walked by. I got them to test it as laypeople and was able to make further refinements based on their perspective and came to know the value of beta testing. its hard to view your own project as an objective user and so that was really helpful insight. 

at this point now i've got a functional manually controlled music visualizer, which is something that i always dreamed of as a kid! so much fun, and i hope to continue this project as i advance in skill, as the ideas just keep coming, many of them unfeasible due to time or framework constraints. a non exhaustive list: more geometric modes, audio responsiveness, pause menu, opening menu, control scheme diagram, tutorial. thank you and this was CS50!